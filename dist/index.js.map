{
  "version": 3,
  "sources": ["../src/hooks/utils.ts", "../src/hooks/ContentEditable.ts", "../src/hooks/History.ts", "../src/hooks/Selection.ts"],
  "sourcesContent": ["export const getTarget = (el: HTMLElement): string =>\n  el.getAttribute('phx-target')!;\n", "import { ViewHook } from './types';\nimport { getTarget } from './utils';\n\nconst resolveCell = (node: Node | HTMLElement): HTMLElement | null => {\n  // the current node is the cell we are looking for\n  if ('dataset' in node && node.dataset.cellId) {\n    return node;\n  }\n\n  // the current node is the block container. if we got here, means we (probably)\n  // only have one cell to pick\n  if ('dataset' in node && 'block' in node.dataset) {\n    return node.querySelector('[data-cell-id]');\n  }\n\n  // the current node is a fragment child node of the cell\n  if (node.parentElement?.dataset.cellId) {\n    return node.parentElement;\n  }\n\n  return null;\n};\n\nconst applyFixes = (el: HTMLElement) => {\n  const zeroth = el.childNodes[0];\n\n  if (!zeroth) {\n    return;\n  }\n\n  // this means we had a blank cell. since we can't put a carret into black inline elements, it was\n  // placed on an extra text node outside in the block, but before the first cell\n  if (zeroth.nodeName === '#text') {\n    // we first have to remove the text log\n    el.removeChild(zeroth);\n\n    // then we prepend the content of the removed text node into the actual first cell element\n    el.childNodes[0].textContent = (zeroth.textContent || '').concat(\n      el.childNodes[0].textContent || ''\n    );\n\n    // finally, since the caret was at the end of that node, we move it into the node\n    const selection = document.getSelection();\n    if (!selection) {\n      return;\n    }\n\n    const range = selection.getRangeAt(0);\n    range.selectNode(el.childNodes[0]);\n    selection.collapseToEnd();\n  }\n\n  if (zeroth?.nodeName === 'BR') {\n    el.removeChild(zeroth);\n  }\n};\n\nconst getPreCaretText = (element: HTMLElement): string => {\n  const selection = document.getSelection();\n  if (!selection) {\n    return '';\n  }\n  const range = selection.getRangeAt(0);\n\n  // generates dom container for selection from start of contenteditable to caret\n  const preCaretRange = range.cloneRange();\n  preCaretRange.selectNodeContents(element);\n  preCaretRange.setEnd(range.startContainer, range.startOffset);\n  const preContainer = document.createElement('div');\n  preContainer.append(preCaretRange.cloneContents());\n  return preContainer.innerText;\n};\n\nconst isAtStartOfBlock = (element: HTMLElement): boolean =>\n  getPreCaretText(element).length === 0;\n\nconst getSelection = () => {\n  const selection = document.getSelection();\n  if (!selection || !selection.anchorNode || !selection.focusNode) {\n    return;\n  }\n\n  const startElement = resolveCell(selection.anchorNode);\n  const endElement = resolveCell(selection.focusNode);\n\n  if (!startElement) {\n    return null;\n  }\n\n  if (!endElement) {\n    return null;\n  }\n\n  const startId = startElement.dataset.cellId;\n  const endId = endElement.dataset.cellId;\n\n  const [startOffset, endOffset] =\n    selection.anchorOffset < selection.focusOffset\n      ? [selection.anchorOffset, selection.focusOffset]\n      : [selection.focusOffset, selection.anchorOffset];\n\n  return {\n    start_id: startId,\n    start_offset: startOffset,\n    end_id: endId,\n    end_offset: endOffset,\n  };\n};\n\ntype Cell = {\n  id: string;\n  modifiers: ('strong' | 'italic')[];\n  text: string;\n};\n\nconst getCells = (el: HTMLElement): Cell[] => {\n  const children = Array.from(el.children) as HTMLElement[];\n\n  return children.map((child) => {\n    const modifiers: ('strong' | 'italic')[] = [];\n\n    if (child.tagName === 'strong') {\n      modifiers.push('strong');\n    }\n\n    if (child.tagName === 'em') {\n      modifiers.push('italic');\n    }\n\n    return {\n      id: child.dataset.cellId || '',\n      text: child.innerText,\n      modifiers,\n    };\n  });\n};\n\nconst resolveCommand = (e: KeyboardEvent) => {\n  if (e.key === 'Backspace') {\n    if (isAtStartOfBlock(e.target as HTMLElement)) {\n      return 'backspace_from_start';\n    }\n  }\n\n  if (e.shiftKey && e.key === 'Enter') {\n    return 'split_line';\n  }\n\n  if (e.key === 'Enter') {\n    return 'split_block';\n  }\n\n  if (e.metaKey && e.key === 'b') {\n    return 'toggle.bold';\n  }\n\n  if (e.metaKey && e.key === 'i') {\n    return 'toggle.italic';\n  }\n};\n\nconst restoreSelection = (el: HTMLElement): void => {\n  // if the block is the focused block, the backend will insert these data\n  // attributes onto the containing element\n  const {\n    selectionStartId,\n    selectionEndId,\n    selectionStartOffset,\n    selectionEndOffset,\n  } = el.dataset;\n\n  if (\n    !selectionStartId ||\n    !selectionEndId ||\n    !selectionStartOffset ||\n    !selectionEndOffset\n  ) {\n    return;\n  }\n\n  // we know the element needs to be focused, just not fully clear where yet\n  el.focus();\n\n  const selection = el.ownerDocument.getSelection();\n  if (!selection) {\n    return;\n  }\n  selection.removeAllRanges();\n\n  const range = document.createRange();\n\n  const focusStart = el.querySelector(`[data-cell-id=\"${selectionStartId}\"]`);\n  if (!focusStart) {\n    return;\n  }\n\n  const offsetStart = parseInt(selectionStartOffset);\n\n  if (!focusStart.childNodes[0]) {\n    focusStart.appendChild(document.createTextNode(''));\n  }\n  range.setStart(focusStart.childNodes[0], offsetStart);\n\n  const focusEnd = el.querySelector(`[data-cell-id=\"${selectionEndId}\"]`);\n  if (!focusEnd) {\n    return;\n  }\n  const offsetEnd = parseInt(selectionEndOffset);\n  range.setEnd(focusEnd.childNodes[0], offsetEnd);\n  selection.addRange(range);\n};\n\nexport const ContentEditable = {\n  mounted() {\n    const el: HTMLElement = (this as any).el;\n\n    let saveRef: null | number = null;\n    let savePromise: Promise<void> | null = null;\n\n    el.addEventListener('input', () => {\n      if (saveRef) {\n        clearTimeout(saveRef);\n      }\n\n      const eventName = 'update';\n      const target = getTarget(this.el);\n\n      savePromise = new Promise((resolve, reject) => {\n        applyFixes(el);\n        const cells = getCells(el);\n        const selection = getSelection();\n        const params = { selection, cells };\n\n        saveRef = setTimeout(async () => {\n          (this as any).pushEventTo(target, eventName, params, () => {\n            saveRef = null;\n            savePromise = null;\n            resolve();\n          });\n        });\n      });\n    });\n\n    el.addEventListener('keydown', async (event: KeyboardEvent) => {\n      const command = resolveCommand(event);\n\n      if (!command) {\n        return;\n      }\n\n      event.preventDefault();\n\n      const selection = getSelection();\n\n      if (savePromise && command) {\n        await savePromise;\n      }\n\n      this.pushEventTo(getTarget(el), command, { selection });\n    });\n\n    el.addEventListener('paste', (event: ClipboardEvent) => {\n      event.preventDefault();\n      const target = getTarget(el);\n      this.pushEventTo(target, 'paste_blocks', { selection: getSelection() });\n    });\n\n    restoreSelection(el);\n  },\n\n  updated() {\n    restoreSelection(this.el);\n  },\n} as ViewHook;\n", "import { ViewHook } from './types';\nimport { getTarget } from './utils';\n\nexport const History = {\n  mounted() {\n    document.addEventListener('keydown', (e) => {\n      if (e.key === 'z' && e.metaKey && e.shiftKey) {\n        this.pushEventTo(getTarget(this.el), 'redo');\n        e.preventDefault();\n        return;\n      }\n\n      if (e.key === 'z' && e.metaKey) {\n        this.pushEventTo(getTarget(this.el), 'undo');\n        e.preventDefault();\n        return;\n      }\n\n      if (e.key === 'y' && e.metaKey) {\n        this.pushEventTo(getTarget(this.el), 'redo');\n        e.preventDefault();\n      }\n    });\n  },\n} as ViewHook;\n", "import { ViewHook } from './types';\nimport { getTarget } from './utils';\n\nconst overlaps = (a: HTMLElement, b: HTMLElement): boolean => {\n  const aRect = a.getBoundingClientRect();\n  const bRect = b.getBoundingClientRect();\n\n  return !(\n    aRect.top > bRect.bottom ||\n    aRect.right < bRect.left ||\n    aRect.bottom < bRect.top ||\n    aRect.left > bRect.right\n  );\n};\n\nconst initCopy = (hook: ViewHook) => {\n  document.addEventListener('copy', (event: ClipboardEvent) => {\n    const selected = document.querySelectorAll<HTMLElement>(\n      '.philtre__editor [data-selected]'\n    );\n\n    if (selected.length === 0) {\n      return;\n    }\n\n    event.preventDefault();\n\n    hook.pushEventTo(getTarget(hook.el), 'copy_blocks', {\n      block_ids: Array.from(selected).map((el) => el.id),\n    });\n  });\n};\n\ntype SelectionState = {\n  fromX: number;\n  fromY: number;\n  toX: number;\n  toY: number;\n  selecting: boolean;\n};\n\nconst getWidth = (state: SelectionState): number =>\n  Math.abs(state.toX - state.fromX);\n\nconst getHeight = (state: SelectionState): number =>\n  Math.abs(state.toY - state.fromY);\n\nconst getLeft = (state: SelectionState): number =>\n  Math.min(state.fromX, state.toX);\n\nconst getTop = (state: SelectionState): number =>\n  Math.min(state.fromY, state.toY);\n\nconst showDOM = (selection: HTMLElement): void => {\n  selection.style.display = 'none';\n  selection.style.background = 'rgba(0,0,255,0.1)';\n  selection.style.position = 'fixed';\n  selection.style.display = 'block';\n};\n\nconst updateDOM = (selection: HTMLElement, state: SelectionState): void => {\n  selection.style.left = `${getLeft(state)}px`;\n  selection.style.top = `${getTop(state)}px`;\n  selection.style.width = `${getWidth(state)}px`;\n  selection.style.height = `${getHeight(state)}px`;\n};\n\nconst resetDOM = (selection: HTMLElement, state: SelectionState) => {\n  selection.style.left = `${getLeft(state)}px`;\n  selection.style.top = `${getTop(state)}px`;\n  selection.style.width = `0px`;\n  selection.style.height = `0px`;\n};\n\nconst hideDOM = (selection: HTMLElement): void => {\n  selection.style.display = 'none';\n};\n\nexport const Selection = {\n  mounted() {\n    initCopy(this);\n\n    const selection: HTMLElement = this.el;\n\n    const selectionState: SelectionState = {\n      fromX: 0,\n      fromY: 0,\n      toX: 0,\n      toY: 0,\n      selecting: false,\n    };\n\n    document.addEventListener('mousedown', (event: MouseEvent) => {\n      selectionState.selecting = true;\n      selectionState.fromX = event.x;\n      selectionState.fromY = event.y;\n\n      showDOM(selection);\n    });\n\n    document.addEventListener('mousemove', (event) => {\n      if (!selectionState.selecting) {\n        return;\n      }\n\n      selectionState.toX = event.x;\n      selectionState.toY = event.y;\n\n      updateDOM(selection, selectionState);\n    });\n\n    document.addEventListener('mouseup', () => {\n      selectionState.selecting = false;\n\n      if (getWidth(selectionState) < 5 || getHeight(selectionState) < 5) {\n        return;\n      }\n\n      const allBlocks = document.querySelectorAll<HTMLElement>('[data-block]');\n\n      const results = Array.from(allBlocks).filter((block) =>\n        overlaps(block, selection)\n      );\n\n      const payload = {\n        block_ids: results.map((el) => el.id),\n      };\n      resetDOM(selection, selectionState);\n      hideDOM(selection);\n\n      this.pushEventTo(getTarget(this.el), 'select_blocks', payload);\n    });\n  },\n} as ViewHook;\n"],
  "mappings": "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",
  "names": []
}
