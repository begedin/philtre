{
  "version": 3,
  "sources": ["../src/hooks/utils.ts", "../src/hooks/ContentEditable.ts", "../src/hooks/History.ts", "../src/hooks/Selection.ts"],
  "sourcesContent": ["export const getTarget = (el: HTMLElement): string => {\n  const target = el.getAttribute('phx-target');\n  if (!target) {\n    throw new Error('Target element does not have a \"phx-target\" attribute');\n  }\n  return target;\n};\n", "import { ViewHook } from './types';\nimport { getTarget } from './utils';\n\nconst resolveCell = (node: Node | HTMLElement): HTMLElement | null => {\n  // the current node is the cell we are looking for\n  if ('dataset' in node && node.dataset.cellId) {\n    return node;\n  }\n\n  // the current node is the block container. if we got here, means we (probably)\n  // only have one cell to pick\n  if ('dataset' in node && 'block' in node.dataset) {\n    return node.querySelector('[data-cell-id]');\n  }\n\n  // the current node is a fragment child node of the cell\n  if (node.parentElement?.dataset.cellId) {\n    return node.parentElement;\n  }\n\n  return null;\n};\n\nconst getChildIndex = (node: Node): number =>\n  Array.prototype.indexOf.call(node.parentNode?.children || [], node);\n\nconst isAtStartOfBlock = (): boolean => {\n  const selection = document.getSelection();\n  if (!selection) {\n    return false;\n  }\n  const node = selection.anchorNode;\n  if (!node) {\n    return false;\n  }\n  const indexedNode = node.nodeType === Node.TEXT_NODE ? node.parentNode : node;\n  if (!indexedNode) {\n    return false;\n  }\n  return getChildIndex(indexedNode) === 0 && selection.anchorOffset == 0;\n};\n\nconst getSelection = () => {\n  const selection = document.getSelection();\n  if (!selection || !selection.anchorNode || !selection.focusNode) {\n    return;\n  }\n\n  const startElement = resolveCell(selection.anchorNode);\n  const endElement = resolveCell(selection.focusNode);\n\n  if (!startElement) {\n    return null;\n  }\n\n  if (!endElement) {\n    return null;\n  }\n\n  const startId = startElement.dataset.cellId;\n  const endId = endElement.dataset.cellId;\n\n  const [startOffset, endOffset] =\n    selection.anchorOffset < selection.focusOffset\n      ? [selection.anchorOffset, selection.focusOffset]\n      : [selection.focusOffset, selection.anchorOffset];\n\n  return {\n    start_id: startId,\n    start_offset: startOffset,\n    end_id: endId,\n    end_offset: endOffset,\n  };\n};\n\ntype Cell = {\n  id: string;\n  modifiers: ('strong' | 'italic')[];\n  text: string;\n};\n\nconst getCells = (el: HTMLElement): Cell[] => {\n  const children = Array.from(el.children) as HTMLElement[];\n\n  return children.map((child) => {\n    const modifiers: ('strong' | 'italic')[] = [];\n\n    if (child.tagName === 'strong') {\n      modifiers.push('strong');\n    }\n\n    if (child.tagName === 'em') {\n      modifiers.push('italic');\n    }\n\n    return {\n      id: child.dataset.cellId || '',\n      text: child.innerText.replace('\u00A0', ' '),\n      modifiers,\n    };\n  });\n};\n\nconst resolveCommand = (e: KeyboardEvent) => {\n  if (e.key === 'Backspace') {\n    if (isAtStartOfBlock()) {\n      return 'backspace_from_start';\n    }\n  }\n\n  if (e.shiftKey && e.key === 'Enter') {\n    return 'split_line';\n  }\n\n  if (e.key === 'Enter') {\n    return 'split_block';\n  }\n\n  if (e.metaKey && e.key === 'b') {\n    return 'toggle.bold';\n  }\n\n  if (e.metaKey && e.key === 'i') {\n    return 'toggle.italic';\n  }\n};\n\nconst restoreSelection = (el: HTMLElement): void => {\n  // if the block is the focused block, the backend will insert these data\n  // attributes onto the containing element\n  const {\n    selectionStartId,\n    selectionEndId,\n    selectionStartOffset,\n    selectionEndOffset,\n  } = el.dataset;\n\n  if (\n    !selectionStartId ||\n    !selectionEndId ||\n    !selectionStartOffset ||\n    !selectionEndOffset\n  ) {\n    return;\n  }\n\n  // we know the element needs to be focused, just not fully clear where yet\n  el.focus();\n\n  const selection = el.ownerDocument.getSelection();\n  if (!selection) {\n    return;\n  }\n  selection.removeAllRanges();\n\n  const range = document.createRange();\n\n  const focusStart = el.querySelector(`[data-cell-id=\"${selectionStartId}\"]`);\n  if (!focusStart) {\n    return;\n  }\n\n  const offsetStart = parseInt(selectionStartOffset);\n\n  if (!focusStart.childNodes[0]) {\n    focusStart.appendChild(document.createTextNode(''));\n  }\n  range.setStart(focusStart.childNodes[0], offsetStart);\n\n  const focusEnd = el.querySelector(`[data-cell-id=\"${selectionEndId}\"]`);\n  if (!focusEnd) {\n    return;\n  }\n  const offsetEnd = parseInt(selectionEndOffset);\n  range.setEnd(focusEnd.childNodes[0], offsetEnd);\n  selection.addRange(range);\n};\n\nexport const ContentEditable = {\n  mounted() {\n    const el: HTMLElement = this.el;\n\n    let saveRef: null | number = null;\n    let savePromise: Promise<void> | null = null;\n\n    el.addEventListener('input', () => {\n      if (saveRef) {\n        clearTimeout(saveRef);\n      }\n\n      const eventName = 'update';\n      const target = getTarget(this.el);\n\n      savePromise = new Promise((resolve) => {\n        const cells = getCells(el);\n        const selection = getSelection();\n        const params = { selection, cells };\n\n        saveRef = window.setTimeout(async () => {\n          this.pushEventTo(target, eventName, params, () => {\n            saveRef = null;\n            savePromise = null;\n            resolve();\n          });\n        }, 300);\n      });\n    });\n\n    el.addEventListener('keydown', async (event: KeyboardEvent) => {\n      const command = resolveCommand(event);\n\n      if (!command) {\n        return;\n      }\n\n      event.preventDefault();\n\n      const selection = getSelection();\n\n      if (savePromise && command) {\n        await savePromise;\n      }\n\n      this.pushEventTo(getTarget(el), command, { selection });\n    });\n\n    el.addEventListener('paste', (event: ClipboardEvent) => {\n      event.preventDefault();\n      const target = getTarget(el);\n      this.pushEventTo(target, 'paste_blocks', { selection: getSelection() });\n    });\n\n    restoreSelection(el);\n  },\n\n  updated() {\n    restoreSelection(this.el);\n  },\n} as ViewHook;\n", "import { ViewHook } from './types';\nimport { getTarget } from './utils';\n\nexport const History = {\n  mounted() {\n    document.addEventListener('keydown', (e) => {\n      if (e.key === 'z' && e.metaKey && e.shiftKey) {\n        this.pushEventTo(getTarget(this.el), 'redo');\n        e.preventDefault();\n        return;\n      }\n\n      if (e.key === 'z' && e.metaKey) {\n        this.pushEventTo(getTarget(this.el), 'undo');\n        e.preventDefault();\n        return;\n      }\n\n      if (e.key === 'y' && e.metaKey) {\n        this.pushEventTo(getTarget(this.el), 'redo');\n        e.preventDefault();\n      }\n    });\n  },\n} as ViewHook;\n", "import { ViewHook } from './types';\nimport { getTarget } from './utils';\n\nconst overlaps = (a: HTMLElement, b: HTMLElement): boolean => {\n  const aRect = a.getBoundingClientRect();\n  const bRect = b.getBoundingClientRect();\n\n  return !(\n    aRect.top > bRect.bottom ||\n    aRect.right < bRect.left ||\n    aRect.bottom < bRect.top ||\n    aRect.left > bRect.right\n  );\n};\n\nconst initCopy = (hook: ViewHook) => {\n  document.addEventListener('copy', (event: ClipboardEvent) => {\n    const selected = document.querySelectorAll<HTMLElement>(\n      '.philtre__editor [data-selected]'\n    );\n\n    if (selected.length === 0) {\n      return;\n    }\n\n    event.preventDefault();\n\n    hook.pushEventTo(getTarget(hook.el), 'copy_blocks', {\n      block_ids: Array.from(selected).map((el) => el.id),\n    });\n  });\n};\n\ntype SelectionState = {\n  fromX: number;\n  fromY: number;\n  toX: number;\n  toY: number;\n  selecting: boolean;\n};\n\nconst getWidth = (state: SelectionState): number =>\n  Math.abs(state.toX - state.fromX);\n\nconst getHeight = (state: SelectionState): number =>\n  Math.abs(state.toY - state.fromY);\n\nconst getLeft = (state: SelectionState): number =>\n  Math.min(state.fromX, state.toX);\n\nconst getTop = (state: SelectionState): number =>\n  Math.min(state.fromY, state.toY);\n\nconst showDOM = (selection: HTMLElement): void => {\n  selection.style.display = 'none';\n  selection.style.background = 'rgba(0,0,255,0.1)';\n  selection.style.position = 'fixed';\n  selection.style.display = 'block';\n};\n\nconst updateDOM = (selection: HTMLElement, state: SelectionState): void => {\n  selection.style.left = `${getLeft(state)}px`;\n  selection.style.top = `${getTop(state)}px`;\n  selection.style.width = `${getWidth(state)}px`;\n  selection.style.height = `${getHeight(state)}px`;\n};\n\nconst resetDOM = (selection: HTMLElement, state: SelectionState) => {\n  selection.style.left = `${getLeft(state)}px`;\n  selection.style.top = `${getTop(state)}px`;\n  selection.style.width = `0px`;\n  selection.style.height = `0px`;\n};\n\nconst hideDOM = (selection: HTMLElement): void => {\n  selection.style.display = 'none';\n};\n\nexport const Selection = {\n  mounted() {\n    initCopy(this);\n\n    const selection: HTMLElement = this.el;\n\n    const selectionState: SelectionState = {\n      fromX: 0,\n      fromY: 0,\n      toX: 0,\n      toY: 0,\n      selecting: false,\n    };\n\n    document.addEventListener('mousedown', (event: MouseEvent) => {\n      if (event.button !== 0) {\n        return;\n      }\n\n      selectionState.selecting = true;\n      selectionState.fromX = event.x;\n      selectionState.fromY = event.y;\n\n      showDOM(selection);\n    });\n\n    document.addEventListener('mousemove', (event) => {\n      if (!selectionState.selecting) {\n        return;\n      }\n\n      selectionState.toX = event.x;\n      selectionState.toY = event.y;\n\n      updateDOM(selection, selectionState);\n    });\n\n    document.addEventListener('mouseup', () => {\n      selectionState.selecting = false;\n\n      const allBlocks = document.querySelectorAll<HTMLElement>('[data-block]');\n\n      const results = Array.from(allBlocks).filter((block) =>\n        overlaps(block, selection)\n      );\n\n      const payload = {\n        block_ids: results.map((el) => el.id),\n      };\n      resetDOM(selection, selectionState);\n      hideDOM(selection);\n\n      this.pushEventTo(getTarget(this.el), 'select_blocks', payload);\n    });\n  },\n} as ViewHook;\n"],
  "mappings": "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",
  "names": []
}
